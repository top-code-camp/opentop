# -*- coding: utf-8 -*-
import numpy as np
import taichi as ti
from Gui_utils import Gui
from topopt5 import topOpt

if __name__ == '__main__':

    # Suguang:
    # GUI is fun when it works. Many thanks to Yisi and Yuqi.
    # GUi is not so convenient when one has to repeat one design many times. 
    # I suggest we support also hdf5 file as input and output file for professional use.
    # Yuqi has already done some code to save the problem and results in hdf5 files.
    
    # volume fraction limit
    frac = 0.25

    ti.init(arch=ti.gpu)
    gui = Gui()

    points=[]
    draw = 1
    # Define the design domain by hand drawing. 
    # A polyline will be generated by connecting each two subsequently created points.
    # A closed polygon will be generated based on the polylines. 
    while draw == 1:
        gui.text(content=f'Draw anything you want, press SPACE to continue.',
                 pos=(0, 0.99),
                 font_size=80,
                 color=0x0)
        # Press 'Shift' to enforce the orthogonality between the newly generated line and the last generated line
        for e in gui.get_events(ti.GUI.PRESS):
            if e.key == ti.GUI.LMB:
                if gui.is_pressed('Shift'):
                    if len(points)<1:
                        points.append(e.pos)
                    else:
                        num = len(points)
                        pre_point = points[num-1]
                        dx = np.abs(pre_point[0]-e.pos[0])
                        dy = np.abs(pre_point[1]-e.pos[1])
                        if dx<dy:
                            temp_point = [pre_point[0],e.pos[1]]
                        else:
                            temp_point = [e.pos[0],pre_point[1]]
                        points.append(temp_point)
                else:
                    points.append(e.pos)
            # Press 'SPACE' to complete the drawing of the design domain
            if e.key == ti.GUI.SPACE:
                draw = 0
        if len(points)>0:
            gui.circles(pos=np.array(points), color=0xFF0000, radius=10)
            for i in range(len(points)-1):
                gui.line(begin=points[i], end=points[i+1], radius=2, color=0xFF0000)
        gui.show()

    points = points[0:len(points)-1]
    # Initialize the optimization parameters
    topIns = topOpt(points, frac)
    # KE = topIns.KE
    # p = topIns.p
    eleNodeList = topIns.eleNodeList
    nodeList = topIns.nodeList
    # eleCenter = topIns.eleCenter
    # eleDof = topIns.eleDof
    # nd = topIns.nele
    nnode = topIns.nnode  
    cpNode = np.zeros(nnode,dtype=int)  # cpNode is the nodes for definition of boundary constraints
    ncp = 0 # the current number of all nodes in the boundary constraints. It changes after selection.
    nfdof = 0 # the current number of all dofs in the loading conditions. It changes after selection.
    fdof = np.zeros(100,dtype=int) # fdof is a list of dofs bearing the applied loads
    scale = 1
    nodeList1 = scale * nodeList
    gui.set_disp_param(nodeList1, eleNodeList)
   
    count = 0
    while True:
        gui.text(content=f'Press B and click two points to select an area, within which the nodes will be fixed, press F and click to select node to apply force.',
                 pos=(0, 0.99),
                 font_size=30,
                 color=0x0)
        dispx = 1 - topIns.x[-1] if len(topIns.x) != 0 else (1-topIns.frac)*np.ones(topIns.nele)
        gui.triangles(gui.a1, gui.b1, gui.c1, color=ti.rgb_to_hex([dispx, dispx, dispx]))
        for e in gui.get_events(ti.GUI.PRESS):
            # Press 'LMB' (Left Mouse Button) to proceed into the selection of points for boundary and force definition
            if e.key == ti.GUI.LMB:
                # Press 'b' to select points for definition of boundary constraints
                if gui.is_pressed('b'):
                    if count == 0:
                        print("Start point", e.pos)
                        start1 = np.array([e.pos[0], e.pos[1]])
                        distx0 = (start1[0] - nodeList1[:, 0])
                        disty0 = (start1[1] - nodeList1[:, 1])
                    if count == 1:
                        print("End point", e.pos)
                        end1 = np.array([e.pos[0], e.pos[1]])
                        distx1 = (end1[0] - nodeList1[:, 0])
                        disty1 = (end1[1] - nodeList1[:, 1])
                        idx1 = np.argwhere((distx0 * distx1) < 0).flatten()
                        idx2 = np.argwhere((disty0 * disty1) < 0).flatten()
                        idx = np.intersect1d(idx1,idx2)  # Only select the points locating within the rectangle defined by two diagonal vertices [start1, end1]
                        cpNode[ncp:ncp+len(idx)] = idx.astype(int)
                        ncp = ncp+len(idx)
                    count = (count+1) % 2
                # Press 'f' to select points for application of external force
                if gui.is_pressed('f'):
                    pos1 = np.array([e.pos[0], e.pos[1]])
                    dist0 = (pos1[0] - nodeList1[:, 0]) ** 2
                    dist1 = (pos1[1] - nodeList1[:, 1]) ** 2
                    dist = np.sqrt(dist0 + dist1)
                    idx = np.argmin(dist)
                    fdof[nfdof] = 2 * idx + 1 # Suguang: force in x-direction?
                    nfdof += 1
                    gui.circle(pos=ti.Vector([e.pos[0], e.pos[1]]), color=0xFF0000, radius=10)
            # Press 'r' to run the optimization program
            if e.key == 'r':
                fdof = fdof[:nfdof]
                cpNode = cpNode[:ncp]
                topIns.run(cpNode, fdof, gui.disp)
        gui.circles(pos=nodeList1[cpNode[0:ncp], :], color=0xFF0000, radius=2)
        gui.show()
